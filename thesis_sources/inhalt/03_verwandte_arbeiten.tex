\chapter{Verwandte Arbeiten}
Für die Bearbeitung der Masterarbeit existieren mehrere Vorarbeiten, die verwendet werden. Zunächst untersuchte bereits Annika Kies, inwiefern die \gls{gui}-Oberflächen von Computerspielen erlernt werden können \cite{kiesEntwicklungUndAnalyse2020}. In ihrer Bachelorarbeit untersuchte sie, ob neuronale Netze erlernen können, Computerspiele zu spielen. Hierfür entwickelte sie, ähnlich dem Ansatz dieser Masterarbeit, Autoencoder-Architekturen, um die Komplexität der Eingabedaten zu verringern. Kern ihrer Bachelorarbeit war es jedoch, Informationen aus der \gls{gui} über die derzeitige Spielsituation zu lernen, und nicht, \gls{gui}-Elemente zu erkennen. Beiden Arbeiten ist zwar gemein, dass jeweils wenige Pixel auf einem Bild besonders wichtig sein können, nichtsdestotrotz sind die wichtigen Elemente der \gls{gui} fundamental verschieden.

%Die beschriebene Problematik der unterschiedlichen Wichtigkeit von Pixeln ist ein Ergebnis ihrer Arbeit, sodass sie einige Handlungsempfehlungen gibt, wie beispielsweise dem unterschiedlichen Gewichten von Bildbereichen oder Pixeln. Diese können in dieser Masterarbeit weiter verfolgt und evaluiert werden.

Eine weitere Vorarbeit ist eine Dummy-Applikation\footnote{\url{https://github.com/neuroevolution-ai/MonkeyTestingDummyApp}, letzter Zugriff: 13.12.2021}, die im Rahmen eines Universitätspraktikums entstanden ist. Mit dieser Applikation wurden jedoch bisher keine Experimente durchgeführt, unter anderem, da diese in Python geschrieben ist und deshalb eine eher schlechte Ausführungsgeschwindigkeit aufweist. Die Applikation verfolgt auch ein anderes Ziel: die Anbindung der am Lehrstuhl entwickelten \gls{ctrnn} über einfachere Convolutional-Schichten.

Darüber hinaus existieren in der Forschungsgemeinschaft Ansätze, die Elemente des maschinellen Lernens verwenden, um \gls{gui}-Oberflächen zu testen.
Bauersfeld et al. \cite{bauersfeldUserInterfaceLevel} entwickelten einen Selektionsmechanismus, der auf dem von ihnen entwickelten \gls{gui}-Test-Framework \emph{TESTAR} \cite{bauersfeldGUITestJavaLibrary2012} aufsetzt. Im Gegensatz zu dieser Arbeit wird für die Erkennung von \gls{gui}-Elementen jedoch keine Bilderkennung verwendet, sondern die Accessibility API\footnote{\url{https://developer.apple.com/library/archive/documentation/Accessibility/Conceptual/AccessibilityMacOSX/}, letzter Zugriff: 13.12.2021} von macOS. Diese API ist in macOS-native Applikationen eingebaut und gibt auf Anfrage beliebige \gls{gui}-Elemente zurück. Unter macOS ist sie somit weit verbreitet, sodass keine Erkennung der \gls{gui}-Elemente benötigt wird. Die entsprechenden Lösungen sind jedoch auf macOS limitiert und können nicht auf andere Betriebssysteme oder Geräteklassen ausgeweitet werden. Wann welche Aktion durchführbar ist, muss des Weiteren auch durch den Tester definiert werden, womit ein entsprechender Zeitaufwand verbunden ist. Die durchführbaren Aktionen werden als Markov-Entscheidungsproblem modelliert, bevor Aktionen mit der Technik \emph{Q-Learning} generiert werden. Das Ziel hierbei ist eine \gls{gui} zu explorieren und dabei die Aktionen höher zu gewichten, die noch nicht ausgeführt wurden oder hinter denen sich Aktionen verbergen, die noch nicht ausgeführt wurden. Diese Berechnung wird durch eine Reward-Funktion durchgeführt.

AutoBlackTest \cite{marianiAutoBlackTestAutomaticBlackBox2012} liegt ein ähnlicher Ansatz zugrunde, der ebenfalls auf Q-Learning basiert. Hier können \gls{gui}-Oberflächen getestet werden, die durch den IBM Functional Tester\footnote{\url{https://www.ibm.com/docs/en/rft/10.0.2?topic=SSJMXE_10.0.2/com.ibm.rational.test.ft.ovrvw.doc/topics/c_test_app_dom_sup.html}, letzter Zugriff: 13.12.2021} unterstützt werden. Beide Ansätze unterscheiden sich von dem in dieser Masterarbeit vorgestellten Ansatz dahingehend, dass sie durch Technologien eingeschränkt sind.

%Darüber hinaus werden bei beiden Ansätzen die verwendeten Modelle während der Erkundung der \gls{gui} erstellt. Die hier verwendeten Autoencoder sowie die in Zukunft eingesetzten Netze werden jedoch vor dem Testvorgang trainiert. Durch das vorherige Training ist es daher möglich, dass diese daher zum Testzeitpunkt schnellere Ergebnisse erbringen können. Daneben könnte auch die Parallelisierbarkeit besser sein, da während dem Testvorgang keine Ergebnisse aus der Vergangenheit verwendet werden müssen. Stattdessen benötigt jeder Testvorgang nur die im Voraus trainierten, gleichen, Netze.

Daneben entwickelten Choi et al. \cite{choiGuidedGUITesting2013} den Ansatz \emph{Swift-Hand}, der aus dem Bereich des Active Learning stammt. Swift-Hand funktioniert ausschließlich mit Android-Apps und deren (nativen Schnittstellen). Der Ansatz funktioniert so, dass ein Modell einer \gls{gui} während dem Testen erstellt und exploriert wird, wobei durchgehend neue Zustände erstellt, aber auch vereinigt werden können. Auch dieser Ansatz unterscheidet sich vom vorliegenden darin, dass er nur für eine bestimmte Technologie (Android-Applikationen) geeignet ist.
% Genauso wird auch hier das Modell während der Ausführung der Tests dynamisch erstellt und nicht im Voraus.

Aus dem Bereich der suchbasierten Ansätze kommt EXSYST \cite{grossSearchbasedSystemTesting2012}. Hierbei kommen genetische Algorithmen zum Einsatz, in denen eine Population an Testsuiten mit Hilfe von Randomisierung (\emph{Mutation}) so verändert wird, dass sich ein Optimum durchsetzt. Auch EXSYST ist nicht technologieagnostisch, sondern unterstützt ausschließlich Java-Swing-Applikationen.

Alle hier vorgestellten Ansätze unterscheiden sich vom vorliegenden Ansatz dahingehend, dass diese sich auf den Teil beschränken, der durch die am \gls{fzi} entwickelten \gls{ctrnn} übernommen wird. Die Erkennung der \gls{gui}-Elemente, um die es in dieser Arbeit geht, wird von den beschriebenen Ansätzen nicht betrachtet, da dieser Vorgang durch Schnittstellen übernommen wird. Der hier vorgestellte Ansatz benötigt dagegen lediglich valide Ansichten der \gls{gui}.

%Ein Training gibt es hier nicht ebenso nicht, sodass die Optimierung zur Laufzeit stattfindet.

\todo{Vorarbeit: Visual Doom von Alvernaz und Togelius (siehe Arbeit von Annika)}
